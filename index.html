<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Abstractions.win</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono:wdth,wght@62.5..100,100..900&family=Noto+Sans:ital,wdth,wght@0,62.5..100,100..900;1,62.5..100,100..900&display=swap" rel="stylesheet">
        <style type="text/css">
            html {
                font-size: 16px;
                font-family: 'Noto Sans';
            }
            body {
                width: 100%;
                min-height: 100vh;
                margin: 0;
            }
            header {
                padding: 1rem 6rem;
            }
            .nav-logo {
                font-family: 'Noto Sans Mono';
                display: flex;
                flex-direction: row;
                align-items: center;
            }
            .nav-logo img {
                width: 48px;
                height: 48px;
            }
            .nav-logo span {
                transform: translateX(-0.75rem);
                font-weight: 400;
                font-size: 1rem;
            }

            h1,h2,h3,h4,h5,h6 {
                font-weight: normal;
                margin: 0;
            }

            article {
                margin: 12rem 6rem;
                display: flex;
                flex-direction: column;
                font-size: 1.25rem;
            }

            .article-category {
                font-family: 'Noto Sans Mono';
                color: rgb(120, 120, 120);
                font-weight: bold;
                text-underline-offset: 0.325em;
                text-decoration-thickness: 2px;
                font-size: 1.25rem;
                margin: 1.75rem 0;
                align-self: start;
            }

            article h1 {
                font-size: 6rem;
                font-family: 'Noto Sans Mono';
                max-width: 100rem;
            }

            article h1:before {
                content: '_';
                width: 1em;
                display: inline-block;
                margin-left: -1.6em;
                transform: translateX(0.75em);
            }

            .bold-1 {
                font-weight: 900;
                font-variation-settings: "wght" 900;
            }

            .article-info {
                display: flex;
                flex-wrap: wrap;
                flex-direction: row;
                font-size: 1.25rem;
                margin: 1.75rem 0rem;
                font-family: 'Noto Sans Mono';
                color: rgb(120, 120, 120);
                font-weight: bold;
            }
            .article-info > *:not(:last-child) {
                margin-right: 5rem;
            }

            .article-info address {
                font-style: normal;
            }

            article h2 {
                font-size: 5rem;
                font-weight: 200;
                font-stretch: 100%;
                font-variation-settings: "wght" 200, "wdth" 100;
                margin: 6rem 0 2.5rem;
                line-height: 95%;
            }
            article h3 {
                font-size: 2.5rem;
                font-weight: 700;
                font-stretch: 70%;
                font-variation-settings: "wght" 700, "wdth" 70;
                margin: 2rem 0 0.5rem;
                line-height: 100%;
            }

            article section {
                max-width: 60rem;
                font-stretch: 100%;
                font-variation-settings: "wdth" 100;
            }

            article section > p:first-of-type::first-letter {
                float: left;
                font-family: 'Noto Sans Mono';
                font-weight: 900;
                font-size: 4rem;
                margin: 0.25rem 0.25rem 0.25rem 0;
                display: inline-block;
            }

            .article-teaser {
                font-size: 1.5rem;
                color: rgb(30, 30, 30);
                max-width: 64rem;
                background-color: rgb(245, 245, 245);
                padding: 2rem 2.5rem;
                margin: 2rem -2.5rem;
            }

            p {
                margin: 0;
            }
            p + p {
                margin-top: 1em;
            }

            article a {
                font-family: 'Noto Sans Mono';
                font-stretch: 75%;
                font-weight: 600;
                font-variation-settings: "wdth" 75, "wght" 600;
                text-decoration: 2px underline;
                text-underline-offset: 0.3rem;
            }

            code {
                font-family: 'Noto Sans Mono';
                font-weight: normal;
                font-stretch: 90%;
                font-variation-settings: "wdth" 90;
            }

            .line-pref {
                display: flow-root;
            }

            .list--spaced-items li + li {
                margin-top: 1.5rem;
            }

            @media (max-width: 800px) {
                html {
                    font-size: 14px;
                }

                header {
                    padding: 1rem 4rem;
                }

                article {
                    margin: 8rem 4rem;
                }

                article h1 {
                    font-size: 4.5rem;
                }

                article h2 {
                    font-size: 4rem;
                }
            }

            @media (max-width: 600px) {
                html {
                    font-size: 13px;
                }

                header {
                    padding: 1rem 2rem;
                }

                article {
                    margin: 4rem 2rem;
                }

                article h1 {
                    font-size: 3.5rem;
                }

                article h2 {
                    font-size: 3rem;
                }
            }
        </style>
    </head>
    <body>
        <header>
            <nav>
                <a class="nav-logo">
                    <img src="/logo.webp">
                    <span>abstractions.win</span>
                </a>
            </nav>
        </header>
        <main>
            <article>
                <a href="/proglang" class="article-category">Programming languages</a>
                <h1>
                    <span class="bold-1">Next genera&shy;tion pro&shy;gram&shy;ming lang&shy;uage:</span>
                    <span>moving up a level of ab&shy;strac&shy;tion</span>
                </h1>
                <div class="article-info">
                    <address>Niels Roesen Abildgaard</address>
                    <time>2024-08-14</time>
                </div>
                <div class="article-teaser">
                    <p>
                        What would it take to change everything about how we write code?
                    </p>
                    <p>
                        The next generation of programming languages will let us write programs in more abstract language, closer to how we would naturally describe their functioning, while losing nothing in precision of the definition.
                    </p>
                    <p>
                        It will change the way we think about and conceptualize programs and allow us&mdash;as software developers&mdash;to more easily navigate complex domains and programs.
                    </p>
                    <p>
                        This article explores what such a programming language might look like.
                    </p>
                </div>
                <section>
                    <h2>Introduction</h2>
                    <p>
                        There are no silver bullets, and nothing will suddenly make software developers perfectly efficient.
                        At the same time, developer tooling is an area of development seeing a lot of investment, both in terms of money and time, and for good reason.
                        The software development industry is unique in two significant ways:
                        <ol>
                            <li>that the tools we use for our job are the same we use to improve our own tools, and</li>
                            <li>that the way we design those tools is limited by the same skills that we use in our work in general.</li>
                        </ol>
                    </p>
                    <p>
                        One of the core skills of software development, and programming in particular, is competently navigating <em>levels of abstraction</em>.
                        Readability of code correlates with how well designed the abstractions are, and how consistently and clearly their boundaries are defined.
                        Similarly, maintainability of large systems becomes easier when abstractions are well-designed, so changes to the requirements for the system are unlikely to require a complete redesign of abstractions.
                        In a sense, defining and using abstractions is how we communicate programs to other developers, and this communication is at the very core of being a skilled software developer.
                    </p>
                    <p>
                        When I teach junior developers about levels of abstraction, in order to help then reason about and have a way to evaluate this skill, I usually start by explaining terms.
                        A common understanding is that the word <em>abstract</em> is more or less equivalent to the word <em>vague</em>&mdash;but that is a terrible starting point for understanding the concept of <em>abstraction</em> and how to navigate levels of abstraction.
                        The opposite of vague is <em>precise</em>.
                        In software development we always need to be precise, in both our conception and communication.
                        So precise, in fact, that a computer can ultimately evaluate what we write and execute it as a program.
                    </p>
                    <p>
                        The opposite of abstract, at least as we use it in software development, is <em>concrete</em>.
                        A function defined on a single level of abstraction should be implemented with statements on a lower (but not too low!) level of abstraction.
                        In other words, a function name describes an action, and its implementation clearly shows the steps required to perform that action.
                        These substeps are themselves functions.
                    </p>
                    <p>
                        A whole program can be conceived as nested functions all the way down to the basic constructs of a language (functions, variables, expressions), which themselves ultimately code for machine code to be evaluated.
                        This forms a directed graph of references with a clear starting point: the program itself.
                        The program node is the most abstract, and we call this the <em>highest level of abstraction</em>.
                        The machine code is the most concrete, and we call this the <em>lowest level of abstraction</em> (at least for most purposes&mdash;it may sometimes be necessary to look at even lower levels, such as actual operations performed in physical hardware).
                        In this view of software, any reference that moves from a low level of abstraction to a high level of abstraction is an indication of poorly concepted code that will be hard to rearrange, maintain and read.
                    </p>
                    <p>&lt;!-- request for illustration: graph of a program, highlight indications of poor abstraction --&gt;</p>
                    <p>
                        A common mistake that results in software that is hard to refactor is making abstractions that are too constrained.
                        Abstractions that allow only a very particular usage pattern is prone to change whenever any logic changes.
                        Such abstractions are called <em>shallow</em>.
                        On the other hand, <em>deep</em> abstractions are generalized enough in their interface that they allow flexible reuse.
                        Such abstractions are more likely to be long-lasting and useful even as programs go through many iterations.
                        (For more on this terminology, see <a href="https://web.archive.org/web/20240804063107/https://web.stanford.edu/~ouster/cgi-bin/book.php" target="_blank" rel="noopener">John Ousterhout, <em>A Philosophy of Software Design</em></a>, pp. 19-27.)
                    </p>
                    <p>
                        While building deep and well-behaved abstractions always improves the quality of a program, it is absolutely essential for creating programming languages.
                        A programming language with shallow abstractions will not be generally usable, and so not much of a programming language at all.
                        A programming language with poor conception of different levels of abstraciton will be incomprehensible and impossible to build an intuition around.
                    </p>
                    <p>
                        The interface of a programming language is the syntax.
                        With a syntax that is Turing complete, it is definitely a deep abstraction.
                        Even then, not all programming languages are made the same.
                        While the C programming language is, by its authors, called “relatively ‘low level’ language” (<a href="https://web.archive.org/web/20240516025121/https://www.cs.princeton.edu/~bwk/cbook.html" target="_blank" rel="noopener">Kernighan & Richie, <em>The C Programming Language</em>, 2<sup>nd</sup> ed.</a>, p. 1), it certainly defines an interface at a higher level of abstraction than assembly languages, which in turn are higher level than machine code.
                    </p>
                    <p>
                        An obvious avenue of inquiry becomes apparent:
                        What are the highest abstraction level programming languages in existence today?
                        And what would an even higher abstraction level programming language look like?
                    </p>

                    <h3>Problems in the current definition of <span class="line-pref">programming language generations</span></h3>
                    <p>
                        A lot of modern languages copy features readily from each other.
                        There especially seems to be a lot of sharing of base concepts between languages like Java, C#, Javascript and Rust, and these languages borrow a lot of concepts from functional programming, despite fitting poorly into that general paradigm.
                        While the languages are different, they seem to be acting on a similar level of abstraction, with similar concept making sense.
                    </p>
                    <p>
                        Contrast this with C, which does not have first class functions (but still allows passing function references around via pointers, albeit without closure scope capture) or futures/promises with <code>async</code>/<code>await</code> syntax (but still allows asynchronous execution and coordination through other mechanisms).
                    </p>
                    <p>
                        To push this point even further, assembly languages don't have the concept of blocks or scopes, relying instead on explicit <code>jump</code>s (like C's <code>goto</code>) for control flow.
                        But assembly languages internally share most of their functionality, making moving from one to another easier than e.g. moving from C to x86 assembly.
                        Finally, machine code compiles away even the labels required for function/procedure calls compile away, and only the concept of stack frames remains as a trace of them.
                    </p>
                    <p>
                        The idea that certain languages are more or less compatible in the kinds of constructs that can easily be implemented in them indicates that some kind of categorization must be possible.
                        Java and C# are very similar, and both are very dissimilar from Assembly.
                    </p>
                    <p>
                        An influential taxonomy of programming languages that attempts something along these lines is that of <em>programming language generations</em>.
                        In this taxonomy, machine code is a first generation language (1GL), assembly a second-generation language (2GL) and languages like C is a third-generation language (3GL).
                        So far so good: this fits the intuition I have sketched above.
                    </p>
                    <p>
                        Framing programming languages in terms of generations implies some form of forward progress, that each new generation keeps what was essential and valuable, more or less unequivocally improves on the previous generation, and enables entirely new ways of making, evaluating or even running programs.
                    </p>
                    <p>
                        For the first two generational steps this progress is clear: assembly allows for the definition of functions, and jumping to code by name rather than line number, and even the easy creation of (heap allocated) named variables.
                        C (or now lesser-known but similar languages like Cobol and Fortran) introduced the concept of nested blocks and scope for variables, explicit parameter passing to functions (instead of placing values in the correct registers before calling), explicit pointer syntax, and more fundamental data types (arrays, integers, floating point numbers).
                        The commonly used definitions for fourth-generation (4GL) and fifth-generation (5GL) languages are a lot less intuitive.
                    </p>
                    <p>
                        I haven't been able to trace the exact place the terminology of programming language generations was introduced (although there seems to be some consensus that it first appeared with third-generation languages, in order to capture what was happening in programming language design at the time), or find any comprehensive or really meaningful definitions.
                        (If you have good sources on the origin of this, I'd be very interested&mdash;reach me at <a href="mailto:niels+abstractions@deranged.dk">niels+abstractions@deranged.dk</a>.)
                    </p>
                    <p>
                        One paper (<a href="https://www.witpress.com/Secure/elibrary/papers/SEHE95/SEHE95020FU.pdf" target="_blank" rel="noopener">M. P. Lee, <em>A novel course in structured systems analysis</em>, 1995</a>, p. 154), typical of its kind, provides an overview of some generations of languages (3GL-5GL) categorizing them based on <em>decade</em>, <em>paradigm</em>, <em>basis</em>.
                        The data for this table is almost entirely unsourced and it is unclear how it is constructed.
                        According to the table, 3GLs are procedural, file based languages from the 1960s (but C is from 1972); 4GLs are hybrid, data based languages from the 1970s (and SQL is indeed from 1974); and 5GLs are declarative knowledge based languages from the 1980s (but Prolog is from 1972).
                        Ultimately this paper argues that Prolog, in particular, can both be considered a 5GL (as it will often be) or a 4GL.
                    </p>
                    <p>
                        In <a href="https://web.archive.org/web/20240816122849/https://books.google.dk/books?hl=da&lr=&id=VjHk2Cjrti8C&oi=fnd&pg=PA1&ots=IMLuNqzFqD&sig=ZB0ey1Umnfr_aOY81xHm2TUDp5s&redir_esc=y#v=onepage&q&f=false" target="_blank" rel="noopener"><em>Programming in Prolog</em>, W. F. Clocksin & C. S. Mellish</a> explicitly clarify that it doesn't make sense to classify Prolog as an evolution of some other languages (5<sup>th</sup> ed., 2003, p. 2):
                    </p>
                    <blockquote>
                        Prolog developed along an independent track [from languages like Smalltalk-80, C++ and Java] from the ealy 1970s and was inspired by logic programming research [...] Prolog should not be compared with object-oriented languages such as C++ and Java, because Prolog does a completely different job, and uses the word "object" in a completely different way.
                    </blockquote>
                    <p>
                        If we look in industry-specific dictionaries, an old <a href="https://web.archive.org/web/20100824054011/http://www.pcmag.com/encyclopedia_term/0,2542,t=fourth-generation+language&i=43439,00.asp" target="_blank" rel="noopener"><em>PC Magazine Encyclopedia</em> defined</a> highlights the progress between generations of languages, stating that a 4GL "is a computer language that is more advanced than traditional high-level programming languages", but goes on to exemplify this only through functions at high abstraction levels (using a single <code>list</code> to print entries in a collection&mdash;like modern SQL variants might use <code>SELECT</code>&mdash;instead of specifying how to iterate over the collection, pick relevant information, and print it).
                    </p>
                    <p>
                        Functions at higher level of abstraction are available in all languages that allow function composition, so it would be possible to implement such a function even in assembly.
                        At the same time, it seems nonsensical to categorize a language by its standard library size, so including the function for all collections also doesn't seem like a reasonable requirement.
                        It seems like they are just trying to classify database query languages, which certainly are a particular category, but seem essentially different from the general purpose applicability of machine code, assembly languages or C.
                    </p>
                    <p>
                        I could go on.
                        The general consensus seems to be that 4GLs are domain specific, usually aimed at databases, and 5GLs deal with logic programming, but as I hope I have illustrated there is a lot of disagreement.
                        If you are still in doubt, just check the <a href="https://web.archive.org/web/20240816124149/https://en.wikipedia.org/wiki/Talk:Programming_language_generations#4th_and_5th" target="_blank" rel="noopener">Wikipedia Talk page for <em>Programming language generations</em></a>, where volunteers are still trying to figure out what people meant or how any of it makes sense:
                    </p>
                    <blockquote>
                        <p>There's a completely uncited section at the bottom of the page, which says a lot of stuff which is, as far as I can see either vague or wrong. [...]</p>
                        <p>is history being rewritten here? For the 33 years I've been aware of this classification, the meaning has always been: 1st generation = machine code, 2nd generation = symbolic assemblers, 3rd generation = high level languages, with the term "4th generation" later having been introduced later to differentiate "4th generation" declarative high level languages (such as Prolog, domain-specific languages etc.) from "3rd generation" imperative high level languages (such as Fortran, Pascal, C, etc.) [...]</p>
                        <p>who was the GENIUS to put FORTRAN (the grand-gran-grandfather of all languages) and C++ (an adolescent) ON THE SAME GROUP? NOT TO MENTION "PYTHON" (a baby) JESUS CHRIST [...]</p>
                        <p>I finished a computer science faculty a couple of years ago and the only "generations" talk I heard there was once from an AI teacher CLAIMING (like they all did, without any references) that each generation meant easier programming - 4th being natural language or close enough (SQL), and 5th being visual programming</p>
                    </blockquote>
                    <p>
                        If these are our generations, then we also have to face a sad fact: whether 5GLs are logic programming languages like Prolog or visual programming languges, two things hold true: there haven't been any new generations or major innovations since the 1970s, and the 5GLs have largely been abandoned as people return to 3GLs for general purpose computation, while 4GLs live on in particular domains.
                    </p>
                    <p>
                        A core problem in trying to piece this together is that the field of computer science is <strong>extremely sloppy</strong> when it comes to history.
                        I am always amazed at the number of points simply claimed in many academic paper introductions, even to this day, that I can find no good sources for.
                        And the problem goes way back: while researching for this background section I found a <a href="https://web.archive.org/web/20240428194902/https://dl.acm.org/doi/pdf/10.1145/1464122.1464124" target="_blank" rel="noopener">1963 historical survey of programming systems and languages</a> which starts with the claim that "Twenty years ago, in 1943, there were no Electronic computers."
                        This is the <em>very first sentence of the paper</em>.
                        The first tape-programmable electromechanical computer, <a href="https://web.archive.org/web/20240816130544/https://en.wikipedia.org/wiki/Z3_(computer)" target="_blank" rel="noopener">the Z3</a>, was completed in 1941, and computers relying on electroniic circuits instead of mechanical relays were <a href="https://web.archive.org/web/20240816130426/https://en.wikipedia.org/wiki/Computer#Digital_computers" target="_blank" rel="noopener">in use from 1934</a>.
                    </p>
                    <p>
                        The terrible practice of boldly and on page one making uncited, wrong or nonsensical claims is a proud computer science history.
                        And the problem compounds: new articles looking to cite their claims will find little help in other papers making the same claims.
                        I'm glad this isn't academic writing.
                    </p>

                    <h3>A new taxonomy of <span class="line-pref">programming language generations</span></h3>
                    <p>
                        In order to talk about what comes next, it seems necessary to reestablish a categorization of what came before.
                    </p>
                    <p>
                        Each generation of languages must be directly comparable to see how they build on each other, so it seems reasonable to limit the list of generations to <em>general-purpose programming languages</em>, under the assumption that this group of languages will represent or capture general programming language advancements.
                    </p>
                    <p>
                        In order to talk sensibly about generation of programming languages, each generation should involve, and I quote myself from the previous section, "some form of forward progress, [so] that each new generation keeps what was essential and valuable, more or less unequivocally improves on the previous generation, and enables entirely new ways of making, evaluating or even running programs".
                    </p>
                    <p>
                        With these considerations in mind, we can more or less keep the definitions of 1GL, 2GL, but we must discard 4GL and 5GL.
                        Traditionally, languages like Java, C#, F#, Scala and Python have been categorized as 3GLs with languages like C, COBOL and Fortran.
                        This seems counterintuitive, as they seem to have very little to do with each other, so we will reevaluate 3GLs, but not discard the category outright.
                    </p>
                    <p>
                        The definitions of 4GL and 5GL seem to have been shaped by the idea that <em>next generation</em> sounds like it means <em>better</em> (in some vague sense).
                        There was a lot of innovation in programming language syntax and paradigms at the time of the fourth and fifth generations being coined, let's say 1975 ± 20 years.
                        Paradigms like functional programming, object-oriented programming, logic programming and declarative programming all saw refinements and innovation.
                    </p>
                    <p>
                        As these innovations were happening, maybe, just maybe, some people got the idea that branding their favourite paradigm as the <em>next hot thing</em> would help it become more popular.
                        It seems that 4GL and 5GL are tied incredibly close to programming paradigms and types of syntax.
                        And this isn't a completely unreasonable property to think of as a generational shift in a programming language: the shifts from machine code to assembly and from assembly to Fortran, COBOL and C all involved significant changes in both concepts and syntax.
                        Unfortunately, what we have seen then seems to undo that perspective: the best ideas of functional programming are now all over procedural programming languages; many languages allow some form of embedding of query languages into their syntax.
                        In a word: synthesis.
                        We have seen languages pick the best of several worlds and paradigms, blurring the lines even more between especially 3GL, 4GL and 5GL.
                    </p>
                    <p>
                        This seems to indicate that a lot of these languages were on a similar abstraction level, allowing the same kinds of abstractions to be created.
                        If we see programming language generations as leaps in abstraction, new deep abstractions building on the previous generations, we can try to recategorize languages with the knowledge of which fit together and which don't.
                        A new generation of programming languages should, to paraphrase John Ousterhout's definition of abstractions, <em>provide a simpler interface, which omits unimportant details</em>.
                    </p>
                    <p>
                        Notice how the languages rapidly copying features from each other do not include C, Fortran or Cobol.
                        (Many functional languages are also reticent to copy features from other paradigms, but this seems to often be due to more of a deliberate purism.)
                    </p>
                    <p>
                        One common feature of the languages in question is that they seem to run in virtual machines.
                        Except Rust doesn't fit in here, being compiled to the particular platform it is on.
                        And while Rust does have an intermediate language representation used compile time, and uses a type system to give new types of guarantees, something similar can be said about C with LLVM.
                    </p>
                    <p>
                        The sharing isn't unique to languages with garbage collectors, as Rust is a key example, having a borrow checker and deterministic compile-time ensured memory management.
                        While Zig copies some semantics and ideas from other languages, it is limited by exactly memory management in implementing many of them.
                        Like C, Zig uses manual memory allocation.
                    </p>
                    <p>
                        In the end, it seems that automatic memory management is what separates this class of languages from what cam before.
                        Memory management innovation has been going on at least for as long as Java launched with garbage collection in 1995 (a feature notably absent in C++, launched in 1997).
                        It seems that removing the constraint of manual memory management allowed for more easily building much more complex systems, and package them up neatly as functions.
                    </p>
                    <p>
                        After thinking about this for a couple of years, I haven't been able to find anything as significant as memory management in differentiating types of languages from each other.
                        That means that the last generation was around 30 years ago.
                        Maybe we can find the next level&mdash;and no, it won't be AI engineers (more on that later).
                    </p>
                    <p>
                        As we move into this new taxonomy it is important to keep in mind that any broad taxonomy of a complex domain will never be entirely precise.
                        There will be languages that we cannot place clearly into one generation, but hopefully the taxonomy will give us words to explain how and why the language is caught between generations.
                        Generations should capture big leaps forward in ideas that are unlikely to be undone by future work in the field, not precisely describe every language's every property.
                    </p>
                    <p>
                        Without further ado, a new taxonomy of programming language generations as I see them now:
                        <ol class="list--spaced-items">
                            <li>
                                <strong>Machine code</strong><br>
                                <p>
                                    Code consists of bytes sent directly to the processing part of a computer.
                                    Instructions are interpreted directly by hardware.
                                    Data can be moved to registers or memory.
                                    Stack frames allows state to be isolated by execution context, so procedures can execute predictably.
                                </p>
                            </li>
                            <li>
                                <strong>Assembly languages</strong>
                                <p>
                                    Replaces byte codes with words that mean things.
                                    Assembly languages often compile to several machines or platforms allowing for greater portability.
                                    Adds naming to variables.
                                </p>
                                <p>
                                    Omits unimportant details: addressing code by line, remembering unique byte sequences that code for operations.
                                </p>
                                <p>
                                    Examples: nasm
                                </p>
                            </li>
                            <li>
                                <strong>Scoped function languages</strong>
                                <p>

                                </p>
                                <p>
                                    Omits unimportant details:
                                </p>
                                <p>
                                    Examples: C, Fortran, Cobol
                                </p>
                            </li>
                            <li>
                                <strong>Memory-managed languages</strong>
                                <p>

                                </p>
                                <p>
                                    Omits unimportant details:
                                </p>
                                <p>
                                    Examples: Java, C#, Scala, Python, Rust, Javascript
                                </p>
                            </li>
                        </ol>
                    </p>
                    <p>
                        This taxonomy is not formalized enough to be really academically viable, but I hope it is at least a better starting point than the extremely vague wording used previously.
                        I'm very open to <a href="mailto:niels+abstractions@deranged.dk">hearing your thoughts</a>, especially if you have any thoughts on how to further formalize it without compromizing the reasoning I've laid out.
                    </p>

                    <p>- the question then becomes what a new generation of language would be, and that will be explored below. the goal is to spur thought and collaboration, and bring programming tooling forward a significant amount by iterating on our most significant tool</p>
                    
                    <h3>Innovations in type systems</h3>
                    <p>- type safety innovations: C# and Java bad for type wrangling, which is why there is anyone arguibg for dyn typed langs. Rust and F*. And typescript attributes too. Including limitations.</p>
                    
                    <h3>An alternative to boilerplate</h3>
                    <p>- ai and what it is used for: generating boilerplate, data wrangling for efficiency. Implies we can define what we want more abstractly. But going through ai codegen is bad for the same reasons other codegen is: a bad and imprecise abstraction hampers maintainability.</p>
                    
                    <hr>
                    
                    <p>- Goal of next gen: more expressiveness without losing precision. Less time spent on wrangling of data, types, codegenerators</p>
                </section>
                <section>
                    <h2>Abstracting away data structures</h2>
                    <p>- performance induced data wrangling, memory safety, type wrangling. All of these relate to how we concretely represent data, and as needs change we may need several representations of data in a code base for different purposes (lookups on different keys, eg), or mapped to different representations.</p>
                    <p>- key idea: separate abstract programming (where we define what is significant) from concrete representation (how data is layouted and accessed). We care about precision in representation of what we define, not memory layout or concrete access patterns.</p>

                    <h3>Collections and objects</h3>
                    <p>- a single collection type and a single object type, where use and definition control attributes (see next section) while layout and processing are determined compile time based on those attributes.</p>
                    <p>- example of generalized access: collection[key: value] - can always index on any keys, always get collection or option (if unique key), code ensures we maintain all useful indices</p>
                    <p>- example: define collection of objects, derive attributes from data</p>
                    <p>- justiy simplicity... somehow.</p>

                    <h3>Memory layouters</h3>
                    <p>- attributes indicating use: this function accesses objects by field</p>
                    <p>- defining and innovating on heuristics based data layouters. Based on attributes of objects or collections different layouters will be applicable. Use static analysis to determine best option</p>
                    <p>- potentially improves code reuse if eights for choosing layout can be configured. E.g. in memory constrained</p>
                </section>
                <section>
                    <h2>
                        <span class="line-pref">Attribute-based</span>
                        <span class="line-pref">type system</span>
                    </h2>
                    <p>- brief intro, including idea of fully known values</p>

                    <h3>Basic data types</h3>
                    <p>- number values or ranges</p>
                    <p>- number precision/deimals/integers</p>
                    <p>- string patterns</p>

                    <h3>Complex types</h3>
                    <p>- objects types are by definition, as ar collections. Like typescrpt but more precise.</p>
                    <p>- mapping from one set of field names to another for an object</p>

                    <h3>Assertions and proofs</h3>
                    <p>- attribute assertions are compile time and are like proofs, exposed by functions so everything builds knowledge</p>
                    <p>- proof hints for complex proofs? Maybe as step of assertions to make human approachable unlike f*</p>
                </section>
                <section>
                    <h2>Next up</h2>
                    <p>- Summary of new contributions, request for comment</p>

                    <h3>Prototypes</h3>
                    <p>- implement prototypes of building blocks. Number type sys, string patterns</p>
                    <p>- implement single b-tree indexed db table like collection - inefficient but means we can iterate on language syntax and run programs</p>

                    <h3>Error handling</h3>
                    <p>- error handling</p>

                    <h3>Concurrency</h3>
                    <p>- concurrency</p>
                </section>
            </article>
        </main>
    </body>
</html>